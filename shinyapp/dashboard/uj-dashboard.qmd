---
title: "The Unjournal data dashboard"
server: shiny
format:
  dashboard:
    theme: simplex
    expandable: false
---

```{r}
#| label: setup
#| context: setup
#| include: false

library(conflicted)
library(cowplot)
library(dplyr)
conflicts_prefer(dplyr::filter)
library(DT)
library(forcats)
library(ggplot2)
library(here)
library(lubridate)
library(plotly)  # For interactive hover tooltips
conflicts_prefer(plotly::layout)  # Fix conflict with graphics::layout
library(shiny)
library(stringr)
library(tidyr)

# names are display periods; values are relevant starting dates for data
periods <- c(
  "Ever"      = as.Date("1900-01-01"),
  "12 months" = today() - period(12, "months"),
  "6 months"  = today() - period(6, "months"),
  "3 months"  = today() - period(3, "months"),
  "1 month"   = today() - period(1, "months")
)


my_theme <- theme_minimal() +
      theme(
        legend.position = "none",
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text.y = element_text(size = 16),
        axis.text.x = element_text(size = 14),
        plot.title = element_text(size = 18),
        axis.title = element_text(size = 14)
      )
ggplot2::theme_set(my_theme)

criteria_titles <- c(
        "overall"         = "Overall assessment",
        "adv_knowledge"   = "Advancing knowledge and practice",
        "methods"         = "Methods",
        "logic_comms"     = "Logic and communication",
        "real_world"      = "Real world relevance",
        "gp_relevance"    = "Global relevance/usefulness",
        "claims"          = "Claims and evidence",
        "open_sci"        = "Open, replicable science",
        "merits_journal"  = "Deserved journal tier",
        "journal_predict" = "Predicted journal tier"
      )
```


```{r}
#| label: data-import
#| context: data
#| include: false

research <- readr::read_csv(here("data/research.csv"), show_col_types = FALSE)
ratings <- readr::read_csv(here("data/rsx_evalr_rating.csv"), show_col_types = FALSE) |>
  mutate(
    middle_rating = as.numeric(middle_rating),
    lower_CI = as.numeric(lower_CI),
    upper_CI = as.numeric(upper_CI)
  )

# Load evaluator-paper level data for statistics
eval_paper_level <- readr::read_csv(here("data/evaluator_paper_level.csv"), show_col_types = FALSE)

res_ratings <- inner_join(ratings, research,
                          by = join_by(research == label_paper_title))

research_areas <- unique(res_ratings$main_cause_cat_abbrev)
research_areas <- sort(research_areas)
research_areas <- c("All", research_areas)
names(research_areas) <- research_areas

```


## {.toolbar}

<style>
.selectize-input {
  white-space: nowrap;
  padding-right: 40px !important;  /* More space for dropdown arrow */
  min-width: 100px;
}
.selectize-input .item {
  max-width: calc(100% - 30px) !important;  /* Prevent text from overlapping arrow */
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 5px;
}
/* Fix the dropdown caret position */
.selectize-control.single .selectize-input::after {
  right: 12px !important;  /* Move arrow away from text */
}
.selectize-dropdown {
  width: 450px !important;
  z-index: 9999 !important;  /* Ensure dropdown appears above chart */
}
#period + .shiny-input-select .selectize-dropdown {
  width: 150px !important;
}
/* Force ALL selectize dropdowns to be tall */
.selectize-dropdown {
  z-index: 99999 !important;
}
.selectize-dropdown-content {
  max-height: 350px !important;
  overflow-y: auto !important;
}
/* Ensure nothing clips the dropdown */
.card, .card-body, .bslib-card, .tab-content, .tab-pane, .bslib-grid,
.bslib-grid-item, .html-fill-container, .html-fill-item {
  overflow: visible !important;
}
/* Style dropdown items */
.selectize-dropdown .option {
  padding: 8px 12px !important;
  border-bottom: 1px solid #f0f0f0;
}
.selectize-dropdown .option:hover {
  background-color: #e8f4fc;
}
/* Compact the Graph/Table radio buttons */
#comparison_view .radio {
  margin-bottom: 5px !important;
  margin-top: 0 !important;
}
#comparison_view label {
  padding-left: 20px;
}
/* Make comparison table more compact */
.dataTables_wrapper {
  font-size: 0.85em;
}
</style>

```{r}
selectInput("period", "Period", names(periods))
```

```{r}
selectInput("research_area", "Research area", names(research_areas))
```



```{r}
textOutput("papers_evaluated")
```


## {.tabset}


### Process overview

#### Column {width=33%}

**Research areas**

[Research areas](https://globalimpact.gitbook.io/the-unjournal-project-and-communication-space/policies-projects-evaluation-workflow/considering-projects/what-specific-areas-do-we-cover) of evaluated papers.

```{r}
plotOutput("barplot_areas", height = "400px")
```

#### Column {width=34%}

**Pipeline status**

Current status of all papers proposed for evaluation.

```{r}
plotOutput("barplot_proposals", height = "400px")
```

#### Column {width=33%}

**Sources**

Papers can be chosen for evaluation by Unjournal staff, submitted by authors or by a third party.

```{r}
plotOutput("barplot_sources", height = "400px")
```


### Overall Ratings

#### Column {.tabset}

##### Plot

Overall assessments for each paper by research area. **Hover over points to see paper names.** Crosses show area averages.

```{r}
plotlyOutput("plot_ratings", height = "500px")
```

##### Data Table

Interactive table of overall ratings. Click column headers to sort.

```{r}
DTOutput("table_ratings")
```


### Individual Criteria

#### Column {.tabset}

##### Plot

Detailed evaluations of [different aspects of research quality](https://globalimpact.gitbook.io/the-unjournal-project-and-communication-space/policies-projects-evaluation-workflow/evaluation/guidelines-for-evaluators). **Hover over points to see paper names.** Crosses show per-question averages.

```{r}
plotlyOutput("plot_criteria", height = "600px")
```

##### Data Table

Average ratings by criteria across all papers.

```{r}
DTOutput("table_criteria")
```


### Paper comparison

#### Column {width=75%}

##### Row {height=15%}

```{r}
selectizeInput("comparison_papers", label = "Select papers to compare (click to see full list):",
               choices = character(0), multiple = TRUE, width = "100%",
               options = list(
                 maxOptions = 100,
                 dropdownParent = "body",
                 render = I("
{
    item: function(item, escape) {
      const fullPaperName = item.value;
      const shortenedName = fullPaperName.length > 40
        ? fullPaperName.substring(0, 40) + '...'
        : fullPaperName;
      return '<div class=\"item\">' + escape(shortenedName) + '</div>';
    }
}
"),
                 onInitialize = I("function() { this.$dropdown_content.css('max-height', '350px'); }")
               ))
```

##### Row {height=85%}

```{r}
uiOutput("comparison_output")
```

#### Column {width=25%}

**View:**

```{r}
radioButtons("comparison_view", NULL,
             choices = c("Graph" = "graph", "Table" = "table"),
             selected = "graph")
```

**Instructions:**

Click the dropdown above to select papers for comparison. The dropdown shows all evaluated papers - you can type to search.


### Statistics

#### Column

##### Row {height=18%}

```{r}
uiOutput("stat_summary_cards")
```

##### Row {height=40%}

###### Column {width=50%}

::: {style="margin-top: 8px;"}
**Research Pipeline** - Papers by status
:::

```{r}
plotlyOutput("plot_pipeline_donut", height = "280px")
```

###### Column {width=50%}

::: {style="margin-top: 8px;"}
**Time Spent on Evaluations** (self-reported)
:::

```{r}
uiOutput("hours_stats_summary")
plotlyOutput("plot_time_spent", height = "240px")
```

##### Row {height=42%}

###### Column {width=50%}

**Evaluations Over Time**

```{r}
plotlyOutput("plot_evals_timeline", height = "280px")
```

###### Column {width=50%}

**Evaluation Streams** (academic uses full criteria)

```{r}
plotlyOutput("plot_eval_streams", height = "280px")
```



```{r}
#| label: render-graphics
#| context: server


start_date <- reactive({
  periods[input$period]
})

evals <- reactive({
  res_ratings |>
    filter(
      row_created_date >= start_date(),
      input$research_area == "All" | main_cause_cat_abbrev == input$research_area
    )
})

evaled_research <- reactive({
  research |>
    filter(status %in% "50_published evaluations (on PubPub, by Unjournal)") |>
    # this applies the time filter
    semi_join(evals(), by = join_by(label_paper_title == research))
})

observe({
  titles <- evaled_research() |> pull(label_paper_title) |> sort()
  updateSelectizeInput(inputId = "comparison_papers",
                       choices = titles)
})

proposals <- reactive({
  research |>
      filter(
      input$research_area == "All" | main_cause_cat_abbrev == input$research_area
    )
})

n_evals <- reactive(n_distinct(select(evals(), research, evaluator)))
n_papers <- reactive(nrow(evaled_research()))
all_cats <- reactive({
  evaled_research()$main_cause_cat_abbrev
})
n_areas <- reactive(n_distinct(all_cats()))

n_proposals <- reactive(nrow(proposals()))


output$papers_evaluated <- renderText({
  if (input$research_area == "All") {
    glue::glue("{n_evals()} evaluations of
    {n_papers()} papers in {n_areas()} distinct research areas")
  } else {
    glue::glue("{n_evals()} evaluations of {n_papers()} papers")
  }
})


output$barplot_areas <- renderPlot({
  plot_data <- data.frame(area = all_cats()) |>
    filter( ! is.na(area))

  if (nrow(plot_data) == 0) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No data available", size = 6) +
        theme_void()
    )
  }

  plot_data |>
    mutate(
      area = stringr::str_to_title(area),
      area = forcats::fct_infreq(area),
      area = forcats::fct_rev(area),
    ) |>
    ggplot() +
      geom_bar(aes(y = area, fill = area)) +
      scale_x_continuous(
        breaks = scales::breaks_extended(Q = c(1, 5, 2, 4, 3))
      ) +
      labs(
        title = "Research areas of evaluated papers",
        x = NULL,
        y = NULL
      )
})


output$barplot_proposals <- renderPlot({
  plot_data <- proposals()

  if (nrow(plot_data) == 0) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No data available", size = 6) +
        theme_void()
    )
  }

  plot_data |>
    mutate(
      Status = case_match(status,
        c("03_awaiting authors' consent (if needed) or update",
          "02_final consideration needed",
          "01_Needs prioritization/assessor rating")
          ~ "Under consideration",
        c("de-prioritized bc. of journal-publication status, authors' permission, age, etc.",
          "authors rejected/blocked us",
          "deprioritized -- low ratings/voting",
          "deprioritized -- out of scope or other subjective judgment or managerial concern",
          "deprioritized - no open access version",
          "Not a paper/project")
          ~ "Deprioritized",
        c("Applied and Policy Research Stream",
          "20_awaiting_evaluations",
          "contacting/awaiting_authors_response_to_evaluation",
          "In interim evaluation",
          "10_seeking_(more)_evaluators",
          "04_selected_choose_evaluation_manager")
          ~ "Accepted and under evaluation",
        c("50_published evaluations (on PubPub, by Unjournal)")
          ~ "Evaluation published",
        .default = "Unknown"
      ),
      Status = forcats::fct_relevel(Status,
                                    "Under consideration",
                                    "Deprioritized",
                                    "Accepted and under evaluation",
                                    "Evaluation published", "Unknown"),
      Status = forcats::fct_rev(Status)

    ) |>
    ggplot() +
      geom_bar(aes(y = Status, fill = Status)) +
      labs(
        title = "Status of papers proposed for evaluation",
        x = NULL,
        y = NULL
      )
})


# Interactive plot for Overall Ratings (native plotly to avoid ggplotly conversion issues)
output$plot_ratings <- renderPlotly({
  plot_data <- evals() |>
    filter(criteria == "overall") |>
    filter(!is.na(main_cause_cat_abbrev)) |>
    mutate(
      area = stringr::str_to_title(main_cause_cat_abbrev)
    )

  # Handle empty data case
  if (nrow(plot_data) == 0) {
    return(
      plotly::plot_ly() |>
        plotly::add_annotations(
          text = "No data available",
          x = 0.5, y = 0.5, xref = "paper", yref = "paper",
          showarrow = FALSE, font = list(size = 16)
        ) |>
        plotly::layout(xaxis = list(visible = FALSE), yaxis = list(visible = FALSE))
    )
  }

  # Get area order by frequency
  area_counts <- plot_data |> count(area, sort = TRUE)
  area_order <- rev(area_counts$area)

  # Calculate means for each area
  means <- plot_data |>
    group_by(area) |>
    summarize(mean_rating = mean(middle_rating, na.rm = TRUE), .groups = "drop")

  # Add jitter to y-coordinates for visual spread
  set.seed(42)
  plot_data <- plot_data |>
    mutate(
      y_jitter = as.numeric(factor(area, levels = area_order)) + runif(n(), -0.2, 0.2)
    )

  # Assign colors by area
  n_areas <- length(area_order)
  colors <- scales::hue_pal()(n_areas)
  names(colors) <- area_order

  # Create the plot
  p <- plotly::plot_ly()

  # Add points for each area
  for (i in seq_along(area_order)) {
    area_data <- plot_data |> filter(area == area_order[i])
    p <- p |> plotly::add_trace(
      data = area_data,
      x = ~middle_rating,
      y = ~y_jitter,
      type = "scatter",
      mode = "markers",
      marker = list(color = colors[area_order[i]], size = 10, opacity = 0.7),
      text = ~research,
      hoverinfo = "text",
      showlegend = FALSE
    )
  }

  # Add mean markers (X shapes)
  means <- means |> mutate(y_pos = as.numeric(factor(area, levels = area_order)))
  p <- p |> plotly::add_trace(
    data = means,
    x = ~mean_rating,
    y = ~y_pos,
    type = "scatter",
    mode = "markers",
    marker = list(symbol = "x", size = 12, color = "black", line = list(width = 2)),
    text = ~paste0(area, " average: ", round(mean_rating, 1)),
    hoverinfo = "text",
    showlegend = FALSE
  )

  # Configure layout
  p |> plotly::layout(
    title = list(text = "Overall ratings of papers by research area", font = list(size = 14)),
    xaxis = list(
      title = "Rating (0-100 percentile)",
      range = c(0, 100),
      tickvals = seq(0, 100, 20),
      tickfont = list(size = 11)
    ),
    yaxis = list(
      title = "",
      tickvals = seq_along(area_order),
      ticktext = area_order,
      tickfont = list(size = 12)
    ),
    hoverlabel = list(bgcolor = "white"),
    margin = list(l = 150, t = 50)
  )
})

# Data table for Overall Ratings
output$table_ratings <- renderDT({
  evals() |>
    filter(criteria == "overall") |>
    mutate(
      Area = stringr::str_to_title(main_cause_cat_abbrev)
    ) |>
    select(Paper = research, Area, Rating = middle_rating,
           `Lower CI` = lower_CI, `Upper CI` = upper_CI) |>
    arrange(desc(Rating)) |>
    datatable(
      options = list(
        pageLength = 15,
        dom = 'frtip',
        scrollX = TRUE
      ),
      rownames = FALSE
    ) |>
    formatRound(columns = c("Rating", "Lower CI", "Upper CI"), digits = 1)
})


# Static plot for Individual Criteria
criteria_plot_data <- reactive({
  evals() |>
    select(research, criteria, middle_rating) |>
    mutate(
      scale_0_to_5 = criteria %in% c("merits_journal", "journal_predict"),
      criteria_label = criteria_titles[criteria],
      criteria_label = forcats::fct_relevel(criteria_label, "Overall assessment"),
      criteria_label = forcats::fct_rev(criteria_label)
    ) |>
    filter(!is.na(criteria_label))
})

# Interactive plot for Individual Criteria (native plotly to avoid ggplotly conversion issues)
output$plot_criteria <- renderPlotly({
  plot_data <- criteria_plot_data() |>
    filter(scale_0_to_5 == FALSE)

  # Handle empty data case
  if (nrow(plot_data) == 0) {
    return(
      plotly::plot_ly() |>
        plotly::add_annotations(
          text = "No data available",
          x = 0.5, y = 0.5, xref = "paper", yref = "paper",
          showarrow = FALSE, font = list(size = 16)
        ) |>
        plotly::layout(xaxis = list(visible = FALSE), yaxis = list(visible = FALSE))
    )
  }

  # Get criteria order
  criteria_order <- c(
    "Overall assessment",
    "Advancing knowledge and practice",
    "Methods",
    "Logic and communication",
    "Real world relevance",
    "Global relevance/usefulness",
    "Claims and evidence",
    "Open, replicable science"
  )
  criteria_order <- rev(criteria_order)  # Reverse for bottom-to-top display

  # Calculate means
  means <- plot_data |>
    group_by(criteria_label) |>
    summarize(mean_rating = mean(middle_rating, na.rm = TRUE), .groups = "drop")

  # Add jitter to y-coordinates
  set.seed(42)
  plot_data <- plot_data |>
    mutate(
      y_jitter = as.numeric(factor(criteria_label, levels = criteria_order)) + runif(n(), -0.2, 0.2)
    )

  # Assign colors by criteria
  n_criteria <- length(criteria_order)
  colors <- scales::hue_pal()(n_criteria)
  names(colors) <- criteria_order

  # Create the plot for 0-100 scale criteria
  p1 <- plotly::plot_ly()

  for (i in seq_along(criteria_order)) {
    crit_data <- plot_data |> filter(criteria_label == criteria_order[i])
    if (nrow(crit_data) > 0) {
      p1 <- p1 |> plotly::add_trace(
        data = crit_data,
        x = ~middle_rating,
        y = ~y_jitter,
        type = "scatter",
        mode = "markers",
        marker = list(color = colors[criteria_order[i]], size = 8, opacity = 0.6),
        text = ~research,
        hoverinfo = "text",
        showlegend = FALSE
      )
    }
  }

  # Add mean markers
  means <- means |>
    filter(criteria_label %in% criteria_order) |>
    mutate(y_pos = as.numeric(factor(criteria_label, levels = criteria_order)))

  if (nrow(means) > 0) {
    p1 <- p1 |> plotly::add_trace(
      data = means,
      x = ~mean_rating,
      y = ~y_pos,
      type = "scatter",
      mode = "markers",
      marker = list(symbol = "x", size = 10, color = "black", line = list(width = 2)),
      text = ~paste0(criteria_label, " avg: ", round(mean_rating, 1)),
      hoverinfo = "text",
      showlegend = FALSE
    )
  }

  # Configure layout for p1 (annotations added in final subplot layout)
  p1 <- p1 |> plotly::layout(
    xaxis = list(
      title = "",
      range = c(0, 100),
      tickvals = seq(0, 100, 20),
      tickfont = list(size = 12)
    )
  )

  # Now handle journal tier data (0-5 scale)
  plot_data2 <- criteria_plot_data() |>
    filter(scale_0_to_5 == TRUE)

  if (nrow(plot_data2) == 0) {
    return(p1 |> plotly::layout(hoverlabel = list(bgcolor = "white")))
  }

  journal_criteria <- c("Predicted journal tier", "Deserved journal tier")
  journal_criteria <- rev(journal_criteria)

  means2 <- plot_data2 |>
    group_by(criteria_label) |>
    summarize(mean_rating = mean(middle_rating, na.rm = TRUE), .groups = "drop")

  set.seed(43)
  plot_data2 <- plot_data2 |>
    mutate(
      y_jitter = as.numeric(factor(criteria_label, levels = journal_criteria)) + runif(n(), -0.2, 0.2)
    )

  journal_colors <- scales::hue_pal()(length(journal_criteria))
  names(journal_colors) <- journal_criteria

  # Create second plot for journal tiers
  p2 <- plotly::plot_ly()

  for (i in seq_along(journal_criteria)) {
    crit_data <- plot_data2 |> filter(criteria_label == journal_criteria[i])
    if (nrow(crit_data) > 0) {
      p2 <- p2 |> plotly::add_trace(
        data = crit_data,
        x = ~middle_rating,
        y = ~y_jitter,
        type = "scatter",
        mode = "markers",
        marker = list(color = journal_colors[journal_criteria[i]], size = 8, opacity = 0.6),
        text = ~research,
        hoverinfo = "text",
        showlegend = FALSE
      )
    }
  }

  # Add means for journal tiers
  means2 <- means2 |>
    filter(criteria_label %in% journal_criteria) |>
    mutate(y_pos = as.numeric(factor(criteria_label, levels = journal_criteria)))

  if (nrow(means2) > 0) {
    p2 <- p2 |> plotly::add_trace(
      data = means2,
      x = ~mean_rating,
      y = ~y_pos,
      type = "scatter",
      mode = "markers",
      marker = list(symbol = "x", size = 10, color = "black", line = list(width = 2)),
      text = ~paste0(criteria_label, " avg: ", round(mean_rating, 1)),
      hoverinfo = "text",
      showlegend = FALSE
    )
  }

  # Combine using subplot first, then apply axis settings
  # Create explicit gap between plots using domain settings
  plotly::subplot(p1, p2, nrows = 2, heights = c(0.65, 0.35), shareX = FALSE) |>
    plotly::layout(
      hoverlabel = list(bgcolor = "white"),
      margin = list(l = 220, t = 50, b = 40),
      # Override yaxis (top plot - 0-100 scale criteria) - domain from 42% to 100%
      yaxis = list(
        title = "",
        tickvals = seq_along(criteria_order),
        ticktext = criteria_order,
        tickfont = list(size = 14),
        domain = c(0.42, 1)
      ),
      # Override yaxis2 (bottom plot - journal tiers) - domain from 0% to 28%
      yaxis2 = list(
        title = "",
        tickvals = c(1, 2),
        ticktext = c("Deserved journal tier", "Predicted journal tier"),
        tickfont = list(size = 14),
        domain = c(0, 0.28)
      ),
      xaxis2 = list(
        title = "",
        range = c(0, 5),
        tickvals = seq(0, 5),
        tickfont = list(size = 12)
      ),
      annotations = list(
        list(text = "Ratings by evaluation criteria (0-100 scale)", x = 0.5, y = 1.02,
             xref = "paper", yref = "paper", showarrow = FALSE, font = list(size = 15, color = "#333")),
        list(text = "Journal tier ratings (0-5 scale)", x = 0.5, y = 0.33,
             xref = "paper", yref = "paper", showarrow = FALSE, font = list(size = 15, color = "#333"))
      )
    )
})

# Data table for criteria averages
output$table_criteria <- renderDT({
  criteria_plot_data() |>
    group_by(Criteria = criteria_label) |>
    summarize(
      `Mean Rating` = mean(middle_rating, na.rm = TRUE),
      `Median` = median(middle_rating, na.rm = TRUE),
      `Min` = min(middle_rating, na.rm = TRUE),
      `Max` = max(middle_rating, na.rm = TRUE),
      `N` = n()
    ) |>
    arrange(desc(`Mean Rating`)) |>
    datatable(
      options = list(
        pageLength = 12,
        dom = 't',
        scrollX = TRUE
      ),
      rownames = FALSE
    ) |>
    formatRound(columns = c("Mean Rating", "Median", "Min", "Max"), digits = 1)
})


# Interactive comparison plot with dual x-axes using native plotly
output$plot_comparison <- renderPlotly({
  if (length(input$comparison_papers) == 0) {
    plotly::plot_ly() |>
      plotly::add_annotations(
        text = "Select papers above to compare",
        x = 0.5, y = 0.5, xref = "paper", yref = "paper",
        showarrow = FALSE, font = list(size = 16)
      ) |>
      plotly::layout(xaxis = list(visible = FALSE), yaxis = list(visible = FALSE))
  } else {
    # Define criteria order (Overall at top, Predicted journal tier at bottom)
    criteria_order <- c(
      "Overall assessment",
      "Advancing knowledge",
      "Methods",
      "Logic & communication",
      "Real world relevance",
      "Global relevance",
      "Claims & evidence",
      "Open science",
      "Deserved journal tier",
      "Predicted journal tier"
    )

    # Map criteria codes to short labels
    criteria_short <- c(
      "overall"         = "Overall assessment",
      "adv_knowledge"   = "Advancing knowledge",
      "methods"         = "Methods",
      "logic_comms"     = "Logic & communication",
      "real_world"      = "Real world relevance",
      "gp_relevance"    = "Global relevance",
      "claims"          = "Claims & evidence",
      "open_sci"        = "Open science",
      "merits_journal"  = "Deserved journal tier",
      "journal_predict" = "Predicted journal tier"
    )

    plot_data <- evals() |>
      filter(research %in% input$comparison_papers) |>
      summarize(.by = c(research, criteria),
                rating = mean(middle_rating, na.rm = TRUE)) |>
      mutate(
        rating_scaled = ifelse(criteria %in% c("merits_journal", "journal_predict"),
                        rating * 20, rating),
        criteria_label = criteria_short[criteria]
      ) |>
      filter(!is.na(criteria_label))

    # Get unique papers and assign colors
    papers <- unique(plot_data$research)
    colors <- scales::hue_pal()(length(papers))

    # Create the plot
    p <- plotly::plot_ly()

    # Add traces for each paper
    for (i in seq_along(papers)) {
      paper_data <- plot_data |>
        filter(research == papers[i]) |>
        # Sort by criteria order for proper line connections
        mutate(y_order = match(criteria_label, criteria_order)) |>
        arrange(y_order)

      # Add connecting line
      p <- p |> plotly::add_trace(
        data = paper_data,
        x = ~rating_scaled,
        y = ~criteria_label,
        type = "scatter",
        mode = "lines",
        line = list(color = colors[i], width = 2),
        showlegend = FALSE,
        hoverinfo = "skip"
      )

      # Add points
      p <- p |> plotly::add_trace(
        data = paper_data,
        x = ~rating_scaled,
        y = ~criteria_label,
        type = "scatter",
        mode = "markers",
        marker = list(color = colors[i], size = 10),
        name = substr(papers[i], 1, 40),
        text = ~paste0(research, "<br>Rating: ", round(rating_scaled, 1)),
        hoverinfo = "text"
      )
    }

    # Configure layout with dual x-axes - Journal tier bottom, Percentile top
    # Start at 20 (tier 1) to reduce whitespace
    p |> plotly::layout(
      xaxis = list(
        title = list(text = "Journal tier", font = list(size = 14)),
        range = c(15, 105),
        tickvals = c(20, 40, 60, 80, 100),
        ticktext = c("1", "2", "3", "4", "5"),
        tickfont = list(size = 13),
        side = "bottom",
        showgrid = TRUE,
        gridcolor = "rgba(200,200,200,0.3)"
      ),
      xaxis2 = list(
        title = list(text = "Percentile rank", font = list(size = 14)),
        overlaying = "x",
        side = "top",
        range = c(15, 105),
        tickvals = seq(20, 100, 20),
        tickfont = list(size = 13),
        showgrid = FALSE,
        zeroline = FALSE
      ),
      yaxis = list(
        title = "",
        categoryorder = "array",
        categoryarray = rev(criteria_order),
        tickfont = list(size = 13),
        showgrid = TRUE,
        gridcolor = "rgba(200,200,200,0.3)"
      ),
      legend = list(
        orientation = "h",
        x = 0.5,
        y = 1.1,
        xanchor = "center",
        font = list(size = 11)
      ),
      margin = list(t = 60, l = 170, b = 50, r = 20),
      hoverlabel = list(bgcolor = "white", font = list(size = 12))
    ) |>
    # Add invisible trace to force xaxis2 to show
    plotly::add_trace(
      x = c(20, 100), y = c(criteria_order[1], criteria_order[1]),
      type = "scatter", mode = "markers",
      marker = list(opacity = 0), xaxis = "x2",
      showlegend = FALSE, hoverinfo = "skip"
    )
  }
})

# Comparison data table
output$table_comparison <- renderDT({
  if (length(input$comparison_papers) == 0) {
    data.frame(Message = "Select papers above to compare")
  } else {
    evals() |>
      filter(research %in% input$comparison_papers) |>
      summarize(.by = c(research, criteria),
                rating = mean(middle_rating, na.rm = TRUE)) |>
      mutate(
        criteria_label = criteria_titles[criteria]
      ) |>
      filter(!is.na(criteria_label)) |>
      select(Paper = research, Criteria = criteria_label, Rating = rating) |>
      pivot_wider(names_from = Criteria, values_from = Rating) |>
      datatable(
        options = list(
          pageLength = 15,
          dom = 'ft',
          scrollX = TRUE,
          scrollY = "500px"
        ),
        rownames = FALSE
      ) |>
      formatRound(columns = -1, digits = 1)
  }
})

# Conditional output for comparison view (graph or table)
output$comparison_output <- renderUI({
  if (input$comparison_view == "graph") {
    plotlyOutput("plot_comparison", height = "600px")
  } else {
    DTOutput("table_comparison")
  }
})


output$barplot_sources <- renderPlot({
  plot_data <- evaled_research()

  if (nrow(plot_data) == 0) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No data available", size = 6) +
        theme_void()
    )
  }

  plot_data |>
    mutate(
      Source = case_match(source_main,
        "internal-NBER"                ~ "Internal (NBER)",
        "internal-from-syllabus-agenda-policy-database" ~ "Internal",
        "suggested - internally"       ~ "Internal",
        "submitted (by author(s))"     ~ "Author",
        "suggested - externally"       ~ "Third party",
        "suggested - externally - NGO" ~ "Third party (NGO)",
        .default = "Unknown"
      ),
      Source = forcats::fct_infreq(Source),
      Source = forcats::fct_rev(Source)
    ) |>
    ggplot() +
      geom_bar(aes(y = Source, fill = Source)) +
      scale_x_continuous(
        breaks = scales::breaks_extended(Q = c(1, 5, 2, 4, 3))
      ) +
      labs(
        title = "Sources of evaluated papers",
        x = NULL,
        y = NULL
      )
})


# ============================================
# Statistics Tab Outputs
# ============================================

# Calculate anonymity: based on evaluations (paper-evaluator pairs), not unique evaluators
anonymity_data <- reactive({
  # Count distinct evaluations (paper-evaluator pairs)
  evaluations <- ratings |>
    filter(!is.na(evaluator), evaluator != "") |>
    distinct(research, evaluator) |>
    # Filter out obvious data quality issues (paper titles parsed as evaluator names)
    filter(!str_detect(evaluator, "^https?://"),
           !str_detect(evaluator, "^\\d{4}"),  # Years
           nchar(evaluator) < 100) |>  # Names shouldn't be super long
    mutate(
      # Match: "Evaluator N", "Anon. evaluator N", "Anon. Evaluator N", "Anonymous_N", etc.
      is_anonymous = str_detect(evaluator, regex("^(Evaluator|Anon|Anonymous)", ignore_case = TRUE))
    )

  list(
    total = nrow(evaluations),
    anonymous = sum(evaluations$is_anonymous),
    named = sum(!evaluations$is_anonymous),
    pct_anonymous = round(100 * sum(evaluations$is_anonymous) / nrow(evaluations), 1)
  )
})

# Statistics summary cards
output$stat_summary_cards <- renderUI({
  # Calculate average hours
  hours_data <- eval_paper_level$hours_spent_manual_impute
  hours_data <- hours_data[!is.na(hours_data)]
  avg_hours <- if (length(hours_data) > 0) round(mean(hours_data), 1) else NA

  anon <- anonymity_data()

  # Inline styles for cards
  card_style <- "border-radius: 12px; padding: 20px; color: white; text-align: center; flex: 1; min-width: 180px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"
  value_style <- "font-size: 2.2em; font-weight: bold; margin: 8px 0;"
  label_style <- "font-size: 0.95em; opacity: 0.9;"

  div(
    style = "display: flex; flex-wrap: wrap; gap: 15px; padding: 10px;",
    div(style = paste0(card_style, "background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);"),
        div(style = label_style, "Papers Evaluated"),
        div(style = value_style, n_papers())
    ),
    div(style = paste0(card_style, "background: linear-gradient(135deg, #00BCD4 0%, #0097A7 100%);"),
        div(style = label_style, "Total Evaluations"),
        div(style = value_style, n_evals())
    ),
    div(style = paste0(card_style, "background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);"),
        div(style = label_style, "Avg Hours/Evaluation"),
        div(style = value_style, if (!is.na(avg_hours)) paste0(avg_hours, " hrs") else "N/A")
    ),
    div(style = paste0(card_style, "background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);"),
        div(style = label_style, "% Anonymous Evals"),
        div(style = value_style, paste0(anon$pct_anonymous, "%"))
    )
  )
})

# Hours stats summary
output$hours_stats_summary <- renderUI({
  hours_data <- eval_paper_level$hours_spent_manual_impute
  hours_data <- hours_data[!is.na(hours_data)]

  if (length(hours_data) == 0) {
    return(div("No data available"))
  }

  n <- length(hours_data)
  med <- round(median(hours_data), 1)
  q1 <- round(quantile(hours_data, 0.25), 1)
  q3 <- round(quantile(hours_data, 0.75), 1)
  rng <- paste0(round(min(hours_data), 1), "-", round(max(hours_data), 1))

  div(style = "font-size: 0.85em; color: #666; margin-bottom: 5px;",
      paste0("n=", n, " | Median: ", med, " hrs | IQR: ", q1, "-", q3, " | Range: ", rng)
  )
})

# Time spent histogram
output$plot_time_spent <- renderPlotly({
  hours_data <- eval_paper_level |>
    filter(!is.na(hours_spent_manual_impute)) |>
    select(hours = hours_spent_manual_impute)

  if (nrow(hours_data) == 0) {
    return(
      plot_ly() |>
        add_annotations(text = "No time data available", x = 0.5, y = 0.5,
                        xref = "paper", yref = "paper", showarrow = FALSE)
    )
  }

  plot_ly(hours_data, x = ~hours, type = "histogram",
          marker = list(color = "#28A745", line = list(color = "white", width = 1)),
          hovertemplate = "Hours: %{x}<br>Count: %{y}<extra></extra>") |>
    layout(
      xaxis = list(title = "Hours spent", tickfont = list(size = 11)),
      yaxis = list(title = "Count", tickfont = list(size = 11)),
      bargap = 0.1,
      margin = list(t = 10, b = 40, l = 40, r = 10)
    )
})

# Evaluations over time
output$plot_evals_timeline <- renderPlotly({
  # Get unique evaluation dates from ratings
  eval_dates <- ratings |>
    filter(!is.na(row_created_date)) |>
    mutate(date = as.Date(row_created_date)) |>
    distinct(research, evaluator, date) |>
    arrange(date) |>
    mutate(cumulative = row_number())

  if (nrow(eval_dates) == 0) {
    return(
      plot_ly() |>
        add_annotations(text = "No date data available", x = 0.5, y = 0.5,
                        xref = "paper", yref = "paper", showarrow = FALSE)
    )
  }

  plot_ly(eval_dates, x = ~date, y = ~cumulative, type = "scatter", mode = "lines",
          line = list(color = "#007BFF", width = 2),
          hovertemplate = "Date: %{x}<br>Total evaluations: %{y}<extra></extra>") |>
    layout(
      xaxis = list(title = "Date", tickfont = list(size = 11)),
      yaxis = list(title = "Cumulative evaluations", tickfont = list(size = 11)),
      margin = list(t = 20, b = 50, l = 60, r = 20)
    )
})

# Pipeline donut chart (like Squarespace)
output$plot_pipeline_donut <- renderPlotly({
  # Use full research dataset (not filtered by period/area)
  # Categorize papers into pipeline stages based on status
  pipeline_data <- research |>
    filter(!is.na(status)) |>
    mutate(
      stage = case_when(
        str_detect(status, "50_published") ~ "Evaluated",
        str_detect(status, regex("seeking.*evaluator|awaiting_evaluation", ignore_case = TRUE)) ~ "Evaluating",
        str_detect(status, regex("deprioritized|rejected|blocked|Not a paper", ignore_case = TRUE)) ~ "Deprioritized",
        TRUE ~ "Prioritizing"
      )
    ) |>
    # Only show active pipeline (exclude deprioritized for the donut)
    filter(stage != "Deprioritized") |>
    count(stage)

  if (nrow(pipeline_data) == 0) {
    return(
      plot_ly() |>
        add_annotations(text = "No pipeline data", x = 0.5, y = 0.5,
                        xref = "paper", yref = "paper", showarrow = FALSE)
    )
  }

  # Add colors and factor ordering
  pipeline_data <- pipeline_data |>
    mutate(
      stage = factor(stage, levels = c("Evaluated", "Evaluating", "Prioritizing")),
      color = case_when(
        stage == "Evaluated" ~ "#7BAFD4",
        stage == "Evaluating" ~ "#1D5A8A",
        stage == "Prioritizing" ~ "#4A8C5C",
        TRUE ~ "#999999"
      )
    ) |>
    arrange(stage)

  total_papers <- sum(pipeline_data$n)

  plot_ly(pipeline_data,
          labels = ~stage,
          values = ~n,
          type = 'pie',
          hole = 0.5,
          textinfo = 'value',
          textposition = 'inside',
          insidetextfont = list(color = 'white', size = 12),
          marker = list(colors = pipeline_data$color,
                        line = list(color = 'white', width = 2)),
          hovertemplate = "%{label}<br>%{value} papers<br>%{percent}<extra></extra>") |>
    layout(
      showlegend = TRUE,
      legend = list(orientation = "h", x = 0.5, xanchor = "center", y = -0.15,
                    font = list(size = 11)),
      margin = list(t = 10, b = 50, l = 10, r = 10),
      annotations = list(
        list(text = as.character(total_papers),
             x = 0.5, y = 0.5,
             font = list(size = 20, color = "#333"),
             showarrow = FALSE)
      )
    )
})

# Evaluation streams pie chart
output$plot_eval_streams <- renderPlotly({
  stream_data <- eval_paper_level |>
    filter(!is.na(evaluation_stream)) |>
    count(evaluation_stream) |>
    mutate(
      stream_label = case_when(
        evaluation_stream == "academic" ~ "Academic",
        evaluation_stream == "applied" ~ "Applied",
        TRUE ~ as.character(evaluation_stream)
      ),
      color = case_when(
        evaluation_stream == "academic" ~ "#3498db",
        evaluation_stream == "applied" ~ "#e74c3c",
        TRUE ~ "#95a5a6"
      )
    )

  if (nrow(stream_data) == 0) {
    return(
      plot_ly() |>
        add_annotations(text = "No stream data", x = 0.5, y = 0.5,
                        xref = "paper", yref = "paper", showarrow = FALSE)
    )
  }

  plot_ly(stream_data,
          labels = ~stream_label,
          values = ~n,
          type = 'pie',
          textinfo = 'label+value',
          textposition = 'inside',
          marker = list(colors = stream_data$color),
          hovertemplate = "%{label}<br>%{value} evaluations<br>%{percent}<extra></extra>") |>
    layout(
      showlegend = TRUE,
      legend = list(orientation = "h", x = 0.5, xanchor = "center", y = -0.1),
      margin = list(t = 20, b = 40, l = 20, r = 20)
    )
})


```

